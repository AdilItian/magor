import { Request, Response } from "express";
import Media from "../../models/media";
import { extname } from "path";
import Transcript from "../../models/transcript";
import TranscriptionRequest from "../../models/transcriptionRequest";
import {
  uploadFile,
  checkStatus,
  retrieveTranscript,
} from "../../../services/api-asr-gateway";
import _ from "lodash";
import { uploadTranscriptToAzure } from "../../../services/storage-azure";
import { addMediaToIndexQueue } from "../../../services/transcript-indexer";

export const handleGenerateTranscription = async (
  req: Request,
  res: Response
) => {
  const {
    language = "english",
    audioType = "closetalk",
    audioTrack = "single",
  } = req.body;

  const { id } = req.query;

  try {
    const media = await Media.findById(id);
    const fileUrl = media["tempResourceUrl"];
    const transRequest = new TranscriptionRequest({
      mediaId: id,
      audioType,
      audioTrack,
      language,
    });
    await transRequest.save();
    const asrId = await uploadFile(fileUrl, language, audioType, audioTrack);
    transRequest["asrId"] = asrId;
    await transRequest.save();
    return res.status(200).json({
      success: true,
      transRequest,
    });
  } catch (error) {
    console.log(error);
    return res.status(500).json({
      success: false,
      error,
    });
  }
};

export const handleFetchStatus = async (req: Request, res: Response) => {
  const { media: mediaId, asr: asrId } = req.query;
  try {
    // FETCH STATUS

    const transRequest = await TranscriptionRequest.findOne({
      asrId,
      mediaId: mediaId,
      status: "pending",
    });

    if (_.isNull(transRequest)) {
      return res.status(400).json({ success: false, error: "Job not found." });
    }

    if (_.isUndefined(asrId)) {
      throw new Error("corrupt data");
    }

    // @ts-ignore
    const response = await checkStatus(asrId);

    const asrStatus = response.status;

    if (asrStatus === "processing") {
      return res.json({ success: false, status: "processing" });
    }

    // asrStatus completed

    // @ts-ignore
    const transcriptPath = await retrieveTranscript(asrId);

    //@ts-ignore
    const format = extname(transcriptPath).substring(1);

    const transcript = new Transcript({
      name: `AutoGen: ${new Date()}`,
      format,
      transcriptType: "transcript",
      tempUploadStatus: "success",
      tempResourceUrl: transcriptPath,
      mediaId,
      isAutoGenerated: true,
    });
    await transcript.save();
    console.log(`Generated transcript ID:`, transcript["_id"]);

    uploadTranscriptToAzure(transcript["_id"], transcript["tempResourceUrl"]);

    const media = await Media.findById(mediaId);
    media[`_transcripts`].push(transcript["_id"]);
    media[`_defaultTranscript`] = transcript["_id"];
    await media.save();
    addMediaToIndexQueue(media["_id"]);
    console.log(
      `Added transcript ${transcript["_id"]} to ${media["_id"]} as default!`
    );

    transRequest["status"] = "success";
    await transRequest.save();

    return res.json({ success: true, status: "completed" });
  } catch (error) {
    console.log(error);
    return res.status(500).json({
      success: false,
      error,
    });
  }
};

export const handleFetchCurrentRequests = async (
  req: Request,
  res: Response
) => {
  const { id } = req.query;
  try {
    // FETCH STATUS
    const transRequests = await TranscriptionRequest.find({
      mediaId: id,
      status: "pending",
    });
    return res.status(200).json({ success: true, requests: transRequests });
  } catch (error) {
    console.log(error);
    return res.status(500).json({
      success: false,
      error,
    });
  }
};

export const handleStatusWebhook = async (req: Request, res: Response) => {};
